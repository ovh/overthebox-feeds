#!/bin/sh /etc/rc.common

START=95
STOP=10

EXTRA_COMMANDS="ifup ifdown"
EXTRA_HELP="	ifup	Setup redirect hook on interfaces
	ifdown	Disable redirect hook on interfaces"

USE_PROCD=1
PROG=/usr/bin/ss-redir
TRACK=/usr/bin/ss-redir-track
CPUCOUNT=$(cat /proc/cpuinfo | egrep "core id|physical id" | tr -d "\n" | sed s/physical/\\nphysical/g | grep -v ^$ | sort | uniq | wc -l)
if [ "$CPUCOUNT" -lt "1" ]; then
	CPUCOUNT="1"
fi

IPTN="$(which iptables) -t nat -w"

. /lib/functions.sh
. /lib/functions/network.sh

service_triggers() {
	procd_add_reload_trigger "shadowsocks"
	procd_add_reload_trigger "mwan3"
	procd_add_reload_trigger "network"
}

shadowsocks_add_instance() {
	local conf="$1"

	for i in $(seq 1 $CPUCOUNT); do
		procd_open_instance
		procd_set_param command "$PROG" -c $conf -b 0.0.0.0
		procd_set_param file "$conf"
		procd_set_param limits nofile="51200 51200"
		procd_set_param respawn
		procd_set_param stderr 1
		procd_close_instance
	done
}

shadowsocks_enable_interfaces_hook() {
	if [ -n "$1" ]; then
		for i in $1
		do
			$IPTN -D PREROUTING  -i $i -p tcp -j SOCKS 2>/dev/null
			$IPTN -A PREROUTING  -i $i -p tcp -j SOCKS
		done
	else
		$IPTN -D PREROUTING  -i lan -p tcp -j SOCKS 2>/dev/null
		$IPTN -A PREROUTING  -i lan -p tcp -j SOCKS
		for i in `cat /var/etc/dnsmasq.conf | grep dhcp-range | cut -c12- | cut -f1 -d','`
		do
			$IPTN -D PREROUTING  -i $i -p tcp -j SOCKS 2>/dev/null
			$IPTN -A PREROUTING  -i $i -p tcp -j SOCKS
		done
	fi
}

shadowsocks_disable_interfaces_hook() {
	if [ -n "$1" ]; then
		for i in $1
		do
			$IPTN -D PREROUTING  -i $i -p tcp -j SOCKS 2>/dev/null
		done
	else
		$IPTN -D PREROUTING  -i lan -p tcp -j SOCKS
		for i in `cat /var/etc/dnsmasq.conf | grep dhcp-range | cut -c12- | cut -f1 -d','`
		do
			$IPTN -D PREROUTING  -i $i -p tcp -j SOCKS
		done
	fi
}

generateConfig() {
	local conf
	local server
	local port
	local lport
	local psk
	local timeout
	local method

	local monitoring_ip
	local reliability
	local count
	local tracktimeout
	local interval
	local down
	local up

	config_get conf $1 conf "/etc/shadowsocks.json"
	config_get server $1 server "127.0.0.1"
	config_get port $1 port ""
	config_get lport $1 lport ""
	config_get password $1 password ""
	config_get timeout $1 timeout ""
	config_get method $1 method ""

	config_get monitoring_ip $1 monitoring_ip ""
	config_get reliability $1 trackreliability "1"
	config_get count $1 trackcount "1"
	config_get tracktimeout $1 tracktimeout "2"
	config_get interval $1 trackinterval "5"
	config_get down $1 trackdown "3"
	config_get up $1 trackup "3"

	cat <<BOF >$conf
{
	"server": "$server",
	"server_port": $port,
	"local_port": $lport,
	"password": "$password",
	"timeout": $timeout,
	"method": "$method",
	"dscp": {
		"$(( $lport + 1 ))": "CS7",
		"$(( $lport + 2 ))": "CS6",
		"$(( $lport + 3 ))": "CS5",
		"$(( $lport + 4 ))": "CS4",
		"$(( $lport + 5 ))": "CS3",
		"$(( $lport + 6 ))": "CS2",
		"$(( $lport + 7 ))": "CS1"
	}
}
BOF

	if [ "$server" != "127.0.0.1" ]; then
		shadowsocks_add_instance $conf

		$IPTN -N SOCKS 2>/dev/null

		$IPTN -D SOCKS -d 0.0.0.0/8 -j RETURN 2>/dev/null
		$IPTN -A SOCKS -d 0.0.0.0/8 -j RETURN

		$IPTN -D SOCKS -d 10.0.0.0/8 -j RETURN 2>/dev/null
		$IPTN -A SOCKS -d 10.0.0.0/8 -j RETURN

		$IPTN -D SOCKS -d 127.0.0.0/8 -j RETURN 2>/dev/null
		$IPTN -A SOCKS -d 127.0.0.0/8 -j RETURN

		$IPTN -D SOCKS -d 169.254.0.0/16 -j RETURN 2>/dev/null
		$IPTN -A SOCKS -d 169.254.0.0/16 -j RETURN

		$IPTN -D SOCKS -d 172.16.0.0/12 -j RETURN 2>/dev/null
		$IPTN -A SOCKS -d 172.16.0.0/12 -j RETURN

		$IPTN -D SOCKS -d 192.168.0.0/16 -j RETURN 2>/dev/null
		$IPTN -A SOCKS -d 192.168.0.0/16 -j RETURN

		$IPTN -D SOCKS -d 224.0.0.0/4 -j RETURN 2>/dev/null
		$IPTN -A SOCKS -d 224.0.0.0/4 -j RETURN

		$IPTN -D SOCKS -d 240.0.0.0/4 -j RETURN 2>/dev/null
		$IPTN -A SOCKS -d 240.0.0.0/4 -j RETURN

		$IPTN -D SOCKS -p tcp -m dscp --dscp-class cs7 -j REDIRECT --to-ports $(( $lport + 1 )) 2>/dev/null
		$IPTN -A SOCKS -p tcp -m dscp --dscp-class cs7 -j REDIRECT --to-ports $(( $lport + 1 ))

		$IPTN -D SOCKS -p tcp -m dscp --dscp-class cs6 -j REDIRECT --to-ports $(( $lport + 2 )) 2>/dev/null
		$IPTN -A SOCKS -p tcp -m dscp --dscp-class cs6 -j REDIRECT --to-ports $(( $lport + 2 ))

		$IPTN -D SOCKS -p tcp -m dscp --dscp-class cs5 -j REDIRECT --to-ports $(( $lport + 3 )) 2>/dev/null
		$IPTN -A SOCKS -p tcp -m dscp --dscp-class cs5 -j REDIRECT --to-ports $(( $lport + 3 ))

		$IPTN -D SOCKS -p tcp -m dscp --dscp-class cs4 -j REDIRECT --to-ports $(( $lport + 4 )) 2>/dev/null
		$IPTN -A SOCKS -p tcp -m dscp --dscp-class cs4 -j REDIRECT --to-ports $(( $lport + 4 ))

		$IPTN -D SOCKS -p tcp -m dscp --dscp-class cs3 -j REDIRECT --to-ports $(( $lport + 5 )) 2>/dev/null
		$IPTN -A SOCKS -p tcp -m dscp --dscp-class cs3 -j REDIRECT --to-ports $(( $lport + 5 ))

		$IPTN -D SOCKS -p tcp -m dscp --dscp-class cs2 -j REDIRECT --to-ports $(( $lport + 6 )) 2>/dev/null
		$IPTN -A SOCKS -p tcp -m dscp --dscp-class cs2 -j REDIRECT --to-ports $(( $lport + 6 ))

		$IPTN -D SOCKS -p tcp -m dscp --dscp-class cs1 -j REDIRECT --to-ports $(( $lport + 7 )) 2>/dev/null
		$IPTN -A SOCKS -p tcp -m dscp --dscp-class cs1 -j REDIRECT --to-ports $(( $lport + 7 ))

		$IPTN -D SOCKS -p tcp -j REDIRECT --to-ports $lport 2>/dev/null
		$IPTN -A SOCKS -p tcp -j REDIRECT --to-ports $lport

	fi

	if [ -n "$monitoring_ip" -a -x "$TRACK" ]; then
		if ! $IPTN -C OUTPUT -d $monitoring_ip/32 -p tcp -m comment --comment "ss_monitoring" -j REDIRECT --to-ports $(( $lport + 2 )) 2>/dev/null; then
			$IPTN -A OUTPUT -d $monitoring_ip/32 -p tcp -m comment --comment "ss_monitoring" -j REDIRECT --to-ports $(( $lport + 2 ))
		fi
		procd_open_instance
		procd_set_param command "$TRACK" -r $reliability -c $count -t $tracktimeout -v $interval -o $down -u $up $monitoring_ip
		procd_set_param file "$conf"
		procd_set_param respawn
		procd_set_param stderr 1
		procd_close_instance
	else
		shadowsocks_enable_interfaces_hook
	fi
}

setup_rules() {
	# Keep redirect rules at the end in the same order
	iptables-save | grep "SOCKS" | grep "REDIRECT --to-ports" | sed "s/-A //g" | while read LINE; do
		$IPTN -A $LINE | sh
		$IPTN -D $LINE | sh
	done
}

genrateRules() {
	local ipset proto src_ip src_port sticky dest_ip dest_port use_policy rule timeout

	config_get sticky $1 sticky 0
	config_get timeout $1 timeout 600
	config_get ipset $1 ipset
	config_get proto $1 proto all
	config_get src_ip $1 src_ip 0.0.0.0/0
	config_get src_port $1 src_port 0:65535
	config_get dest_ip $1 dest_ip 0.0.0.0/0
	config_get dest_port $1 dest_port 0:65535
	config_get use_policy $1 use_policy

	rule="$1"

	if [ -n "$use_policy" ]; then
	case $proto in
		tcp)
			$IPTN -D SOCKS -p $proto -s $src_ip -d $dest_ip $ipset -m multiport --sports $src_port -m multiport --dports $dest_port -m comment --comment "mwan3_$1" -j RETURN &> /dev/null
			$IPTN -A SOCKS -p $proto -s $src_ip -d $dest_ip $ipset -m multiport --sports $src_port -m multiport --dports $dest_port -m comment --comment "mwan3_$1" -j RETURN &> /dev/null
			setup_rules
			;;
		udp)
			;;
		*)
			;;
		esac
	fi

}

generateStaticRoutesRules() {
	local interface target netmask gateway metric mtu

	config_get interface $1 interface 'lan'
	config_get target $1 target ''
	config_get netmask $1 netmask '255.255.255.255'
	config_get gateway $1 gateway ''
	config_get metric $1 metric ''
	config_get mtu $1 mtu ''

	if [ -n "$gateway" ] && [ -n "$target" ]; then
		eval "$(ipcalc.sh $target $netmask)"
		if [ "$NETWORK" != "0.0.0.0" ] && [ "$PREFIX" != "0" ]; then
			$IPTN -D SOCKS -d "$NETWORK/$PREFIX" -m comment --comment "ss_staticroute" -j RETURN 2>/dev/null
			$IPTN -A SOCKS -d "$NETWORK/$PREFIX" -m comment --comment "ss_staticroute" -j RETURN
			setup_rules
		fi
	fi
}

generateWanAddress() {
	local ifname ipaddr

	config_get ifname $1 ifname
	network_get_ipaddr ipaddr $ifname

	if [ -n "$ipaddr" ]; then
		$IPTN -D SOCKS -d "$ipaddr/32" -m comment --comment "ss_itf_$ifname" -j RETURN 2>/dev/null
		$IPTN -A SOCKS -d "$ipaddr/32" -m comment --comment "ss_itf_$ifname" -j RETURN
		setup_rules
	fi
}


start_service() {
	config_load shadowsocks
	config_foreach generateConfig client

	config_load mwan3
	config_foreach genrateRules rule

	config_load network
	config_foreach generateWanAddress interface
	config_foreach generateStaticRoutesRules route
}

reload_service() {
	config_load mwan3
	config_foreach genrateRules rule

	config_load network
	config_foreach generateWanAddress interface
	config_foreach generateStaticRoutesRules route
}

stop_service() {
	shadowsocks_disable_interfaces_hook
	$IPTN -F SOCKS
	$IPTN -X SOCKS
	# Clean up monitoring_ip rules
	iptables-save | grep "ss_monitoring" | grep "REDIRECT --to-ports" | sed "s/-A //g" | while read LINE; do
		$IPTN -D $LINE | sh
	done
}

ifup() {
	shadowsocks_enable_interfaces_hook "$@"
}

ifdown() {
	shadowsocks_disable_interfaces_hook "$@"
}
