diff --git a/src/run-openwrt.sh b/src/run-openwrt.sh
index 97171a6..1cf6403 100644
--- a/src/run-openwrt.sh
+++ b/src/run-openwrt.sh
@@ -26,8 +26,8 @@ if [ "$ACTION" = "stop" -a -z "$RUN_IFACE" ]; then
     exit 0
 fi
 
+# Convert SQM entity to network uci section
 config_load sqm
-
 run_sqm_scripts() {
     local section="$1"
     export IFACE=$(config_get "$section" interface)
@@ -36,6 +36,32 @@ run_sqm_scripts() {
 
     [ $(config_get "$section" enabled) -ne 1 ] && ACTION=stop
 
+    if [ "$(uci -q get network.$IFACE)" == "interface" ]; then
+	uci set network.$IFACE.autoshape=static
+	uci set network.$IFACE.upload=$(config_get "$section" upload)
+	uci set network.$IFACE.download=$(config_get "$section" download)
+	uci delete sqm.$section
+    fi
+}
+config_foreach run_sqm_scripts
+
+# Load QoS settings from network uci
+config_load network
+run_sqm_network_scripts() {
+    local section="$1"
+    export IFACE=$(config_get "$section" ifname)
+
+    [ -z "$RUN_IFACE" -o "$RUN_IFACE" = "$IFACE" -o "$RUN_IFACE" = "tun0" ] || return
+    export RUN_IFACE=${RUN_IFACE}
+
+    [ -z "$(config_get "$section" autoshape)" ] && return
+    [ "$(config_get "$section" autoshape)" == "off" ] && {
+	CUR_STATE_FILE="${SQM_STATE_DIR}/${IFACE}.state"
+	if [ -f "${CUR_STATE_FILE}" ]; then
+		"${SQM_LIB_DIR}/stop-sqm"
+	fi
+    }
+
     export UPLINK=$(config_get "$section" upload)
     export DOWNLINK=$(config_get "$section" download)
     export LLAM=$(config_get "$section" linklayer_adaptation_mechanism)
@@ -56,9 +77,11 @@ run_sqm_scripts() {
     export SQUASH_DSCP=$(config_get "$section" squash_dscp)
     export SQUASH_INGRESS=$(config_get "$section" squash_ingress)
 
-    export QDISC=$(config_get "$section" qdisc)
-    export SCRIPT=$(config_get "$section" script)
-
+    local qdisc script
+    config_get qdisc "$section" qdisc "sfq"
+    config_get script "$section" script "otb.qos"
+    export QDISC=$qdisc
+    export SCRIPT=$script
 
     #sm: if SQM_DEBUG was passed in via the command line make it available to the other scripts
     [ -z "$SQM_DEBUG" ] && export SQM_DEBUG
@@ -71,5 +94,6 @@ run_sqm_scripts() {
 
     [ "$ACTION" = "start" ] && "${SQM_LIB_DIR}/start-sqm"
 }
+config_foreach run_sqm_network_scripts
 
-config_foreach run_sqm_scripts
+#EOF
diff --git a/src/otb.qos b/src/otb.qos
new file mode 100644
index 0000000..d276fab
--- /dev/null
+++ b/src/otb.qos
@@ -0,0 +1,247 @@
+#!/bin/sh
+
+# This program is free software moded by Bash; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+
+. ${SQM_LIB_DIR}/defaults.sh
+
+
+
+egress() {
+
+    if [ "$(uci -q get vtund.tunnel.enable)" == "1" ]; then
+        TUN0_PORT=$(uci -q get vtund.tunnel.port || echo "5005")
+    fi
+    if [ "$(uci -q get vtund.xtun0.enable)" == "1" ]; then
+	 XTUN0_PORT=$(uci -q get vtund.xtun0.port || echo "5008")
+    fi
+    if [ "$(uci -q get glorytun.otb.enable)" == "1" ]; then
+        TUN0_PORT=$(uci -q get glorytun.otb.port || echo "5006")
+    fi
+    if [ "$(uci -q get glorytun.xtun0.enable)" == "1" ]; then
+        XTUN0_PORT=$(uci -q get glorytun.xtun0.port || echo "5009")
+    fi
+    SOCKS_PORT=$(uci -q get shadowsocks.proxy.port || echo "1090")
+
+    ipt -t mangle -F QOS_MARK_${IFACE}
+    ipt -t mangle -X QOS_MARK_${IFACE}
+    ipt -t mangle -N QOS_MARK_${IFACE}
+
+    ipt -t mangle -F QOS_RULES_${IFACE}
+    ipt -t mangle -X QOS_RULES_${IFACE}
+    ipt -t mangle -N QOS_RULES_${IFACE}
+
+# Marking dscp SS tagged packets  
+    ipt -t mangle -D OUTPUT -o ${IFACE} -g QOS_MARK_${IFACE} 2>/dev/null
+    ipt -t mangle -I OUTPUT 2 -o ${IFACE} -g QOS_MARK_${IFACE}
+    ipt -t mangle -A QOS_MARK_${IFACE} -j CONNMARK --restore-mark --nfmask ${IPT_MASK} --ctmask ${IPT_MASK}
+    ipt -t mangle -A QOS_MARK_${IFACE} -m mark --mark 0x00${IPT_MASK_STRING} -j QOS_RULES_${IFACE}
+    
+    ipt -t mangle -A QOS_RULES_${IFACE} -p tcp -m multiport --dports ${SOCKS_PORT} -m dscp --dscp-class cs0 --tcp-flags ALL ACK -j MARK --set-mark 0x06${IPT_MASK_STRING}
+    ipt -t mangle -A QOS_RULES_${IFACE} -p tcp -m multiport --dports ${SOCKS_PORT} -m dscp --dscp-class cs1 -m comment --comment "Scavenger" -j MARK --set-mark 0x01${IPT_MASK_STRING}
+    ipt -t mangle -A QOS_RULES_${IFACE} -p tcp -m multiport --dports ${SOCKS_PORT} -m dscp --dscp-class cs2 -m comment --comment "Normal" -j MARK --set-mark 0x02${IPT_MASK_STRING}
+    ipt -t mangle -A QOS_RULES_${IFACE} -p tcp -m multiport --dports ${SOCKS_PORT} -m dscp --dscp-class cs3 -m comment --comment "Signaling" -j MARK --set-mark 0x03${IPT_MASK_STRING}
+    ipt -t mangle -A QOS_RULES_${IFACE} -p tcp -m multiport --dports ${SOCKS_PORT} -m dscp --dscp-class cs4 -m comment --comment "Realtime" -j MARK --set-mark 0x04${IPT_MASK_STRING}
+    ipt -t mangle -A QOS_RULES_${IFACE} -p tcp -m multiport --dports ${SOCKS_PORT} -m dscp --dscp-class cs5 -m comment --comment "BroadcastVideo" -j MARK --set-mark 0x05${IPT_MASK_STRING}
+    ipt -t mangle -A QOS_RULES_${IFACE} -p tcp -m multiport --dports ${SOCKS_PORT} -m dscp --dscp-class cs6 -m comment --comment "NetworkControl" -j MARK --set-mark 0x06${IPT_MASK_STRING}
+    ipt -t mangle -A QOS_RULES_${IFACE} -p tcp -m multiport --dports ${SOCKS_PORT} -m dscp --dscp-class cs7 -m comment --comment "Reserved" -j MARK --set-mark 0x07${IPT_MASK_STRING}
+
+    ipt -t mangle -A QOS_RULES_${IFACE} -p tcp -m multiport --dports ${SOCKS_PORT} -m dscp --dscp-class cs0 -m length --length 512: -m comment --comment "Heavy" -j MARK --set-mark 0x01${IPT_MASK_STRING}
+    ipt -t mangle -A QOS_RULES_${IFACE} -p tcp -m multiport --dports ${SOCKS_PORT} -m dscp --dscp-class cs0 -m length --length 128:512 -m comment --comment "Interactive" --j MARK --set-mark 0x03${IPT_MASK_STRING}
+    ipt -t mangle -A QOS_RULES_${IFACE} -p tcp -m multiport --dports ${SOCKS_PORT} -m dscp --dscp-class cs0 -m length --length 0:128 -m comment --comment "Acknowledge" -j MARK --set-mark 0x06${IPT_MASK_STRING}
+
+    ipt -t mangle -A QOS_MARK_${IFACE} -j CONNMARK --save-mark --nfmask ${IPT_MASK} --ctmask ${IPT_MASK}
+
+########################
+
+# Delete existing queue
+    $TC qdisc del dev ${IFACE} root 2> /dev/null
+# Traffic classes:
+# 1:2 Interactive (SSH, DNS, ACK)
+# 1:3 Low latency (VoIP)
+# 1:4 Browsing (HTTP, HTTPs)
+# 1:5 Default
+# 1:6 Low priority (p2p, pop3, smtp, etc)
+
+# add HFSC root qdisc
+    $TC qdisc add dev ${IFACE} root handle 1: `get_stab_string` hfsc default 5
+
+
+# add main rate limit class
+    $TC class add dev ${IFACE} parent 1: classid 1:1 hfsc \
+                sc rate ${UPLINK}kbit ul rate ${UPLINK}kbit
+
+# Interactive traffic: guarantee realtime full uplink for 50ms, then
+# 50% of the uplink
+
+    $TC class add dev ${IFACE} parent 1:1  classid 1:2 hfsc \
+    rt m1   ${UPLINK}kbit d  50ms m2 $((5*$UPLINK/10))kbit \
+    ls m1   ${UPLINK}kbit d  50ms m2 $((7*$UPLINK/10))kbit \
+    ul rate ${UPLINK}kbit
+
+# VoIP: guarantee full uplink for 200ms, then 30%
+    $TC class add dev ${IFACE} parent 1:1  classid 1:3 hfsc \
+    sc m1 ${UPLINK}kbit d 200ms m2 $((3*$UPLINK/10))kbit \
+    ul rate ${UPLINK}kbit
+
+# Browsing: Don't guarantee anything for the first second, then
+# guarantee 10%
+
+    $TC class add dev ${IFACE} parent 1:1  classid 1:4 hfsc \
+    sc m1         0 d    1s m2 $((1*$UPLINK/10))kbit \
+    ul rate ${UPLINK}kbit
+
+# Default traffic: don't guarantee anything for the first two seconds,
+# then guarantee 5%
+
+    $TC class add dev ${IFACE} parent 1:1  classid 1:5 hfsc \
+    sc m1         0 d    2s m2 $((1*$UPLINK/20))kbit \
+    ul rate ${UPLINK}kbit
+
+# Default traffic: don't guarantee anything for the first 10 seconds,
+# then guarantee 5%
+
+    $TC class add dev ${IFACE} parent 1:1  classid 1:6 hfsc \
+    sc m1         0 d   10s m2 $((1*$UPLINK/20))kbit \
+    ul rate ${UPLINK}kbit
+
+################
+
+    $TC qdisc add dev ${IFACE} parent 1:2 handle 12: ${QDISC} \
+    `get_limit ${ELIMIT}` `get_target "${ETARGET}" ${UPLINK}` `get_ecn ${EECN}` \
+    `get_quantum  300` `get_flows ${PRIO}` ${EQDISC_OPTS}
+    $TC qdisc add dev ${IFACE} parent 1:3 handle 13: ${QDISC} \
+    `get_limit ${ELIMIT}` `get_target "${ETARGET}" ${UPLINK}` `get_ecn ${EECN}` \
+    `get_quantum  300` `get_flows ${NORMAL}` ${EQDISC_OPTS}
+    $TC qdisc add dev ${IFACE} parent 1:4 handle 14: ${QDISC} \
+    `get_limit ${ELIMIT}` `get_target "${ETARGET}" ${UPLINK}` `get_ecn ${EECN}` \
+    `get_quantum  300` `get_flows ${BULK}` ${EQDISC_OPTS}
+    $TC qdisc add dev ${IFACE} parent 1:5 handle 15: ${QDISC} \
+    `get_limit ${ELIMIT}` `get_target "${ETARGET}" ${UPLINK}` `get_ecn ${EECN}` \
+    `get_quantum  300` `get_flows ${BULK}` ${EQDISC_OPTS}
+    $TC qdisc add dev ${IFACE} parent 1:6 handle 16: ${QDISC} \
+    `get_limit ${ELIMIT}` `get_target "${ETARGET}" ${UPLINK}` `get_ecn ${EECN}` \
+    `get_quantum  300` `get_flows ${BULK}` ${EQDISC_OPTS}
+
+
+    # Redirect filtered packets to specific queues
+    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 1 u32 match ip dport ${XTUN0_PORT} 0xffff  flowid 1:3
+    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 1 u32 match ip dport ${TUN0_PORT} 0xffff  flowid 1:5
+
+    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 2 u32 match mark 0x07 ${IPT_MASK} flowid 1:2
+    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 2 u32 match mark 0x06 ${IPT_MASK} flowid 1:2
+    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 2 u32 match mark 0x05 ${IPT_MASK} flowid 1:3
+    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 2 u32 match mark 0x04 ${IPT_MASK} flowid 1:4
+    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 2 u32 match mark 0x03 ${IPT_MASK} flowid 1:4
+    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 2 u32 match mark 0x02 ${IPT_MASK} flowid 1:5
+    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 2 u32 match mark 0x01 ${IPT_MASK} flowid 1:6
+
+    uci set network.${IFACE}.upload_state='up' && uci commit network
+}
+
+ingress() {
+      return
+#    $TC qdisc del dev ${IFACE} handle ffff: ingress 2> /dev/null
+#    $TC qdisc add dev ${IFACE} handle ffff: ingress
+#
+#    $TC qdisc del dev ${DEV} root 2> /dev/null
+#    $TC qdisc add dev ${DEV} root handle 1: `get_stab_string` hfsc default 50
+#
+#    #Use a single queue for ingress.
+#    $TC class add dev ${DEV} parent 1: classid 1:1 hfsc sc rate ${DOWNLINK}kbit ul rate ${DOWNLINK}kbit
+#
+#    $TC class add dev ${DEV} parent 1:1  classid 1:20 hfsc rt m1 ${DOWNLINK}kbit d 50ms m2 $((5*$DOWNLINK/10))kbit ls m1 ${DOWNLINK}kbit d 50ms m2 $((7*$DOWNLINK/10))kbit ul rate ${DOWNLINK}kbit
+#    $TC class add dev ${DEV} parent 1:1  classid 1:30 hfsc sc m1 ${DOWNLINK}kbit d 200ms m2 $((3*$DOWNLINK/10))kbit ul rate ${DOWNLINK}kbit
+#    $TC class add dev ${DEV} parent 1:1  classid 1:40 hfsc sc m1 0 d 1s m2 $((1*$DOWNLINK/10))kbit ul rate ${DOWNLINK}kbit
+#    $TC class add dev ${DEV} parent 1:1  classid 1:50 hfsc sc m1 0 d 2s m2 $((1*$DOWNLINK/20))kbit ul rate ${DOWNLINK}kbit
+#    $TC class add dev ${DEV} parent 1:1  classid 1:60 hfsc sc m1 0 d 10s m2 $((1*$DOWNLINK/20))kbit ul rate ${DOWNLINK}kbit
+#
+#    $TC qdisc add dev ${DEV} parent 1:20 handle 20: ${QDISC} `get_limit ${ILIMIT}` `get_target "${ITARGET}" ${DOWNLINK}` `get_ecn ${IECN}` `get_quantum  1540` `get_flows ${DOWNLINK}` ${IQDISC_OPTS}
+#    $TC qdisc add dev ${DEV} parent 1:30 handle 30: ${QDISC} `get_limit ${ILIMIT}` `get_target "${ITARGET}" ${DOWNLINK}` `get_ecn ${IECN}` `get_quantum  1540` `get_flows ${DOWNLINK}` ${IQDISC_OPTS}
+#    $TC qdisc add dev ${DEV} parent 1:40 handle 40: ${QDISC} `get_limit ${ILIMIT}` `get_target "${ITARGET}" ${DOWNLINK}` `get_ecn ${IECN}` `get_quantum  1540` `get_flows ${DOWNLINK}` ${IQDISC_OPTS}
+#    $TC qdisc add dev ${DEV} parent 1:50 handle 50: ${QDISC} `get_limit ${ILIMIT}` `get_target "${ITARGET}" ${DOWNLINK}` `get_ecn ${IECN}` `get_quantum  1540` `get_flows ${DOWNLINK}` ${IQDISC_OPTS}
+#    $TC qdisc add dev ${DEV} parent 1:60 handle 60: ${QDISC} `get_limit ${ILIMIT}` `get_target "${ITARGET}" ${DOWNLINK}` `get_ecn ${IECN}` `get_quantum  1540` `get_flows ${DOWNLINK}` ${IQDISC_OPTS}
+#
+#    $TC filter add dev ${DEV} parent 20: handle 20 protocol all flow hash keys nfct-src,nfct-dst,nfct-proto,nfct-proto-src,nfct-proto-dst  divisor `get_flows_count ${DOWNLINK}`
+#    $TC filter add dev ${DEV} parent 30: handle 30 protocol all flow hash keys nfct-src,nfct-dst,nfct-proto,nfct-proto-src,nfct-proto-dst  divisor `get_flows_count ${DOWNLINK}`
+#    $TC filter add dev ${DEV} parent 40: handle 40 protocol all flow hash keys nfct-src,nfct-dst,nfct-proto,nfct-proto-src,nfct-proto-dst  divisor `get_flows_count ${DOWNLINK}`
+#    $TC filter add dev ${DEV} parent 50: handle 50 protocol all flow hash keys nfct-src,nfct-dst,nfct-proto,nfct-proto-src,nfct-proto-dst  divisor `get_flows_count ${DOWNLINK}`
+#    $TC filter add dev ${DEV} parent 60: handle 60 protocol all flow hash keys nfct-src,nfct-dst,nfct-proto,nfct-proto-src,nfct-proto-dst  divisor `get_flows_count ${DOWNLINK}`
+#
+#    $IP link set dev ${DEV} up
+#    $TC filter add dev ${IFACE} parent ffff: protocol all prio 1 u32 match u32 0 0 action connmark action mirred egress redirect dev ${DEV} 
+#
+#    $TC filter add dev ${DEV} parent 1:0 protocol all prio 1 u32 match ip sport ${XTUN0_PORT} 0xffff  flowid 1:20
+#    $TC filter add dev ${DEV} parent 1:0 protocol all prio 1 u32 match ip sport ${SOCKS_PORT} 0xffff  flowid 1:60
+}
+
+push_to_api() {
+	local TOKEN METRIC WAN_IP API_IP
+	
+	TOKEN=$(uci -q get overthebox.me.token)
+	METRIC=$(uci -q get network.${IFACE}.metric)
+	if [ "$1" == "stop" ]; then
+		curl -s --connect-timeout 3 -X DELETE api/qos/${METRIC}?auth_token=${TOKEN} && uci set network.${IFACE}.download_state='down' && uci commit network
+	elif [ "$1" == "start" ]; then
+		WAN_IP=$(curl -s --connect-timeout 3 --interface ${IFACE} ifconfig.ovh)
+		if [ -n "${WAN_IP}" ]; then
+			curl -s --connect-timeout 3 -X PUT -H "Content-Type: application/json" --data "{ \"interface\": \"${IFACE}\", \"metric\": \"${METRIC}\", \"wan_ip\": \"${WAN_IP}\", \"downlink\": \"${DOWNLINK}\", \"uplink\": \"${UPLINK}\" }" api/qos?auth_token=${TOKEN} && uci set network.${IFACE}.download_state='up' && uci commit network
+		fi
+	fi
+}
+
+sqm_start() {
+    [ -n "${IFACE}" ] || return 1
+    push_to_api start
+    [ "${RUN_IFACE}" == "tun0" ] && return 1
+    [ -z "$DEV" ] && DEV=$( get_ifb_for_if ${IFACE} )
+    do_modules
+    verify_qdisc "hfsc" || return 1
+    verify_qdisc ${QDISC} || return 1
+    sqm_logger "Starting ${SCRIPT}"
+
+    eth_setup
+    #ipt_setup
+
+    if [ "${UPLINK}" -ne 0 ];
+    then
+        egress
+        sqm_logger "egress shaping activated"
+    else
+        sqm_logger "egress shaping deactivated"
+        $TC qdisc del dev ${IFACE} root 2> /dev/null
+    fi
+    if [ "${DOWNLINK}" -ne 0 ];
+    then
+        verify_qdisc ingress "ingress" || return 1
+        ingress
+        sqm_logger "ingress shaping activated"
+    else
+        sqm_logger "ingress shaping deactivated"
+        $TC qdisc del dev ${DEV} root 2> /dev/null
+        $TC qdisc del dev ${IFACE} ingress 2> /dev/null
+    fi
+    return 0
+}
+
+sqm_stop() {
+    push_to_api stop
+    [ "${RUN_IFACE}" == "tun0" ] && return 1
+
+    $TC qdisc del dev ${IFACE} ingress 2> /dev/null
+    $TC qdisc del dev ${IFACE} root 2> /dev/null
+    uci set network.${IFACE}.upload_state='down' && uci commit network
+    [ -n "$CUR_IFB" ] && $TC qdisc del dev ${CUR_IFB} root 2> /dev/null
+    [ -n "$CUR_IFB" ] && sqm_logger "${0}: ${CUR_IFB} shaper deleted"
+
+
+    ipt -t mangle -D POSTROUTING -o ${IFACE} -g QOS_MARK_${IFACE}
+    ipt -t mangle -F QOS_MARK_${IFACE}
+    ipt -t mangle -X QOS_MARK_${IFACE}
+    ipt -t mangle -F QOS_RULES_${IFACE}
+    ipt -t mangle -X QOS_RULES_${IFACE}  [ -n "$CUR_IFB" ] && $IP link set dev ${CUR_IFB} down
+    
+    [ -n "$CUR_IFB" ] && $IP link delete ${CUR_IFB} type ifb
+    [ -n "$CUR_IFB" ] && sqm_logger "${0}: ${CUR_IFB} interface deleted"
+}
